<!DOCTYPE html>
<html>
<body>
<div style="padding-bottom: 5px;">
	<button type="button" id="startstop">Stop</button>
</div>

<canvas id="myCanvas" width="1024" height="768" style="border:1px solid #d3d3d3; background-color:black;">
Your browser does not support the HTML5 canvas tag.</canvas>



<script>
var gGenerating = true;

var btn = document.getElementById("startstop");
btn.addEventListener("click", function(e){
	gGenerating = !gGenerating;
	if (gGenerating)
		btn.innerText = "Stop";
	else
		btn.innerText = "Start";
});

var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");
var last_time = Date.now();
var run_time = 0;
var wait_time = 1.0;
var frame_count = 0;
var fps = "0";
var PPM = 32; // pixels per 'meter'
var grav = PPM * 9.8;
var half_grav = 0.5 * grav;

function irandom_range(a,b)
{
	if ( b < a ) {
		var c = a;
		a = b;
		b = c;
	}
	
	var r = Math.floor(b) - Math.floor(a);
	return Math.floor( Math.random() * r ) + a;
}

function clamp(val, minVal, maxVal)
{
	return Math.max( minVal, Math.min( maxVal, val ));
}

var CONN_U = 1;
var CONN_D = 2;
var CONN_L = 4;
var CONN_R = 8;

function gen_map(width, height, fill_to)
{
	var directions = [
		[0, -1],
		[0, 1],
		[-1, 0],
		[1, 0]
	];
	
	var map = {
		w: width,
		h: height,
		cells: [],
		connections: []
	};
	
	var is_cell_empty = function(x, y, map)
	{
		if ( x >= 0 && x < map.w && y >= 0 && y < map.h)
			return map.cells[y * map.w + x][0] == 0;
		return false;
	}
	
	for (var i = 0; i < width * height; ++i)
		map.cells[i] = [0, 0];
	
	var cx = irandom_range(0, map.w);
	var cy = irandom_range(0, map.h);
	map.cells[cy * map.w + cx] = [1, 0];
	
	var filled = 0;
	while (filled < fill_to)
	{
		var choices = []
		if (is_cell_empty(cx, cy - 1, map)) choices.push(0);
		if (is_cell_empty(cx, cy + 1, map)) choices.push(1);
		if (is_cell_empty(cx - 1, cy, map)) choices.push(2);
		if (is_cell_empty(cx + 1, cy, map)) choices.push(3);
		
		var ncx;
		var ncy;
		var dir;
		if (choices.length > 0)
		{
			dir = choices[ irandom_range(0, choices.length) ];
		}
		else
		{
			dir = irandom_range(0,4);			
		}
		
		ncx = clamp( cx + directions[dir][0], 0, map.w-1);
		ncy = clamp( cy + directions[dir][1], 0, map.h-1);
		
		//cx = clamp( cx + (Math.random() > 0.5 ? 1 : -1), 0, map.w-1 );
		//cy = clamp( cy + (Math.random() > 0.5 ? 1 : -1), 0, map.h-1 );
		
		if (is_cell_empty(ncx, ncy, map))
		{
			map.cells[ncy * map.w + ncx][0] = 1;
			++filled;
		}		
		
		cx = ncx;
		cy = ncy;
	}
	
	return map;		
}

function draw_map(ctx, map, x, y)
{
	for (var r = 0; r < map.h; ++r)
	{
		for (var c = 0; c < map.w; ++c)
		{
			var cell = map.cells[r * map.w + c];
			ctx.fillStyle = cell[0] == 1 ? "#ffffff" : "#999999";
			ctx.fillRect( x + c * 50, y + r * 25, 45, 20 );
		}
	}
}

function getCursorPosition(canvas, event) {
    var rect = canvas.getBoundingClientRect();
    var x = event.clientX - rect.left;
    var y = event.clientY - rect.top;
    console.log("x: " + x + " y: " + y);
}

canvas.addEventListener("mousedown", function(e){ getCursorPosition(canvas, e); } );

var gMap = gen_map(10, 10, 30);

function loop()
{
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	
	var curr_time = Date.now();
	var dt = (curr_time - last_time) * 0.001;
	
	run_time += dt;
	frame_count += 1;
	
	if (run_time > wait_time) {
		
		wait_time = wait_time + 1;
		//console.log("run_time: " + run_time + " | fps: " + frame_count);
		fps = frame_count;
		frame_count = 0;
		if (gGenerating)
			gMap = gen_map(10, 10, 30);
	}
	
	ctx.fillStyle = "#ffffff";
	
	//ctx.fillRect(0, 200, 1024, 1);
	
	//ctx.fillStyle = "#ff0000";
	//ctx.fillRect(box.x, box.y, box.w, box.h);
	
	draw_map(ctx, gMap, 100, 100);
	
	
	ctx.fillStyle = "#FFFFFF";
	ctx.font = "12px Arial";
	ctx.fillText("FPS "+fps, canvas.width-41, 10);
	ctx.fillText("dt " +dt, 0, 10);
	
	last_time = curr_time;
	
	setTimeout(loop, 1000 / 60);
}

function draw_transformed(point_list, transform)
{
	for(var i = 0; i < point_list.length; ++i)
    {
    	var p = point_list[i];
    	if ("color" in p)
        	ctx.fillStyle = p.color;
        
		
		var z = point2d(mat_vec_mult(transform, [p.x, p.y, 1.0]));
       	//ctx.fillRect(p.x-2 + Math.sin(run_time*2)*10, p.y-2, 5, 5);
		ctx.fillRect(z.x-2, z.y-2, 5, 5);
    }
}

// EXAMPLES ////////////////////

function ex_simple_rotation(time)
{
	return mat2d_rotate(time);
}
function ex_translate(time, amount)
{
	var s = Math.sin(time) * amount;
	var t = Math.sin(time+0.5) * amount;
	return mat2d_translate(s, t);
}
function ex_scale(time, amount)
{
	var s = Math.sin(time) * 0.5 + 0.5
	var t = Math.sin(time+0.5) * 0.5 + 0.5;
	s = s * amount + 1.0;
	t = t * amount + 1.0;
	return mat2d_scale(s, t);
}
function ex_scale_center(time, amount, center)
{
	var sc = ex_scale(time, amount);
	var m = mat2d_translate(-center.x, -center.y);
	var m2= mat2d_translate(center.x, center.y);
	
	return mat3x3_mult(m2, mat3x3_mult(sc, m));	
}
function ex_rotate_center(time, center)
{
	var r = mat2d_rotate(time);
	var t0 = mat2d_translate(-center.x, -center.y);
	var t1 = mat2d_translate(center.x, center.y);
	
	return mat3x3_mult(t1, mat3x3_mult(r, t0));
}
function ex_planets(time, center)
{
	var outs = [];
	
	var p0 = mat2d_translate(512, 384)
	
	var p1 = mat3x3_multX( [
		//p0,
		mat2d_translate(p0[0][2], p0[1][2]),
		mat2d_rotate(time), // orbital rotation
		mat2d_translate(250, 0) // orbital radius
		//mat2d_rotate(time*1.2), // spin
	]);
	
	var p2 = mat3x3_multX( [
		//p1,
		mat2d_translate(p1[0][2], p1[1][2]),
		mat2d_rotate( -time*5 + 10 ), // orbital rotation
		mat2d_translate( 100, 0 ) // orbital radius
	]);
	
	var p3 = mat3x3_multX( [
		mat2d_translate(p0[0][2], p0[1][2]),
		mat2d_rotate(time),
		mat2d_translate(-250, 0)
	]);
	
	var spin_centered = function(transform, theta, center, scale) {
		scale = typeof scale != "undefined" ?  scale : 1;
		
		return mat3x3_multX([
			mat2d_translate(transform[0][2], transform[1][2]),
			mat2d_rotate(theta),
			mat2d_scale(scale, scale),
			mat2d_translate(-center.x, -center.y)
		]);
	}
	
	var s = Math.sin(time) + 2;
	outs.push(spin_centered(p0, time*5, center));
	outs.push(spin_centered(p1, time*10, center));
	outs.push(spin_centered(p2, time*12, {x: center.x, y: center.y})); // off center spin
	outs.push(spin_centered(p3, time*0, center, s));
	return outs;
}

// TRANSFORMATION FUNCTIONS ////////////////////////////////////////
function mat2d_rotate(rad_theta)
{
	var s = Math.sin(rad_theta);
	var c = Math.cos(rad_theta);
	return [ [c, -s, 0], [s, c, 0], [0, 0, 1] ];
}

function mat2d_translate(x, y)
{
	return [ [1,0,x], [0,1,y], [0,0,1] ];
}

function mat2d_scale(x, y)
{
	return [ [x, 0, 0], [0, y, 0], [0, 0, 1] ];
}
	
function mat3x3_mult(a, b) {
	var result = [ 
		[],//[0,0,0],
		[],//[0,0,0],
		[],//[0,0,0] 
	];
	result[0] = [
		a[0][0] * b[0][0] + a[0][1] * b[1][0] + a[0][2] * b[2][0],
		a[0][0] * b[0][1] + a[0][1] * b[1][1] + a[0][2] * b[2][1],
		a[0][0] * b[0][2] + a[0][1] * b[1][2] + a[0][2] * b[2][2]
	];
	result[1] = [
		a[1][0] * b[0][0] + a[1][1] * b[1][0] + a[1][2] * b[2][0],
		a[1][0] * b[0][1] + a[1][1] * b[1][1] + a[1][2] * b[2][1],
		a[1][0] * b[0][2] + a[1][1] * b[1][2] + a[1][2] * b[2][2]
	];
	result[2] = [
		a[2][0] * b[0][0] + a[2][1] * b[1][0] + a[2][2] * b[2][0],
		a[2][0] * b[0][1] + a[2][1] * b[1][1] + a[2][2] * b[2][1],
		a[2][0] * b[0][2] + a[2][1] * b[1][2] + a[2][2] * b[2][2]
	];
	return result;
		
	/*
	for (var i = 0; i < a.length; ++i)
	{
		var row = a[i];
		for ( var j = 0; j < row.length; ++j )
		{
			result[i][j] = 0;
			for ( var col = 0; col < b.length; ++col )
			{
			}
		}
	}
	*/
}
function mat3x3_multX( matArray )
{
	var result = matArray[0];
	for (var i = 1; i < matArray.length; ++i)
		result = mat3x3_mult(result, matArray[i]);
	return result;
}

function mat_vec_mult(mat, vec)
{
	if ( mat[0].length != vec.length ) {
		console.log("mat_vec_mult ERROR: dimension mismatch");
		return Array(mat.length).fill(0);
	}
	var out = [];
	for ( var i = 0; i < mat.length; ++i )
	{
		var v = 0;
		for ( var j = 0; j < vec.length; ++j )
			v = v + vec[j] * mat[i][j];
		out.push( v );
	}
	return out;
}

function mat_point2d_mult(mat, point)
{
	var result = mat_vec_mult(mat, [point.x, point.y, 1.0]);
	point.x = result[0];
	point.y = result[1];
}
function point2d(vec){
	return {x: vec[0], y: vec[1]};
}


var imgData = ctx.createImageData(200, 200);

var i;
for (i = 0; i < imgData.data.length; i += 4) {
  imgData.data[i+0] = Math.sin(((i/4)%200)*0.12) * 64 + 127 + 64
  imgData.data[i+1] = 0;//Math.sin((i%100)*0.01) * 127 + 127;
  imgData.data[i+2] = 0; //Math.cos((i%100)*0.01) * 127 + 127;
  imgData.data[i+3] = 255;
}


ctx.fillStyle = "#00aa88";
//ctx.putImageData(imgData, 10, 10);
//ctx.fillRect(20, 20, 20, 20);

loop();

</script>


</body>
</html>
