<!DOCTYPE html>
<html>
<head>
    <script src="phaser.min.js"></script>
</head>
<body>

	<h2>Running out of space</h2>
    <script>
	var indexes = {
		TOPL: 0,
		TOPC: 1,
		TOPR: 2,
		LEFT: 8,
		FLOOR: 14,
		RIGHT: 10,
		BOTL:  16,
		BOTC: 17,
		BOTR: 18,

		CORNERTL: 3,
		CORNERTR: 4,
		CORNERBL: 11,
		CORNERBR: 12,

		DESTROYED: 34

	};

    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 }
            }
        },
        scene: {
            preload: preload,
            create: create,
			update: update
        }
    };

    var game = new Phaser.Game(config);

    function preload ()
    {
		this.load.image('image_tiles', 'tiles_x2.png');
		this.load.image('swarm', 'swarm.png');
    }

	var wallMap = null;
	var cursors = null;
	var player = null;
	var gfxBodyDebug = null;
	var swarmGroup = null;
	var swarmies = [];
	var tilesToDestroy = null;
	var levelObj = null;

	function create ()
	{
		var lvl = [
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
			[0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0],
			[0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0],
			[0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0],
			[0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0],
			[0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0],
			[0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0],
			[0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0],
			[0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0],
			[0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0],
			[0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0],
			[0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],
			[0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0],
			[0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0],
			[0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
		];

		levelObj = tilemapFromLevel(this, lvl);

		var startx = 150;
		var starty = 100;
		for (var i = 0; i < 5; ++i)
		{
			swarmies.push({
				spr: this.add.sprite(startx,starty,'swarm'),
				off: {x: 0, y:0},
				rot: 1
			});
			if (i > 0)
			{
				var q = swarmies[i];
				q.off.x = Phaser.Math.RND.between(0,20) - 10;
				q.off.y = Phaser.Math.RND.between(0,20) - 10;
				q.rot = Phaser.Math.RND.normal();
				q.spr.setPosition(q.spr.x + q.off.x, q.spr.y + q.off.y);
				
				q.rot = q.rot < 0 ? (q.rot / 2 - 0.5) : (q.rot / 2 + 0.5);
				q.rot = q.rot * 2;
			}
		}
		//swarmGroup = this.add.group(swarmies);

		player = swarmies[0].spr;

		this.physics.add.existing(player);
		player.body.setCircle(8,8,8);

		//player = this.physics.add.sprite(150, 100, 'swarm');
		//player.body.setCircle(8,8,8);
		gfxBodyDebug = this.add.graphics();
		//player.body.drawDebug(gfxBodyDebug);


		this.physics.add.collider(player, levelObj.wallLayer);

		this.cameras.main.startFollow(player);

		cursors = this.input.keyboard.createCursorKeys();

		wallMap = levelObj.map;

		levelObj.wallLayer.setTileIndexCallback(indexes.DESTROYED, OnCollideWithDestroyed, this);
	}

	var destruction_ticker = 0;
	function update(time, delta)
	{
		destruction_ticker += delta;
		if (destruction_ticker > 300.0 && tilesToDestroy.length < 30)
		{
			var layer = levelObj.wallLayer;
			var nextDestruct = {};
			var checkNeighbor = function(l, x, y, list){
				var key = function(t){ return t.x + '-' + t.y; };
				var t = l.getTileAt(x,y);
				if (t.index == indexes.FLOOR && !(key(t) in list))
					list[key(t)] = {x: t.x, y: t.y};
				else
					console.log('non floor index: '+ t.index);
			};
			for (var i = 0; i < tilesToDestroy.length; ++i)
			{
				var t = tilesToDestroy[i];
				layer.putTileAt(indexes.DESTROYED, t.x, t.y);//.setCollision(true);

				//var tx = t.x;
				//var ty = t.y;
				//layer.removeTileAt(tx, ty);
				//t.index = indexes.DESTROYED;
				//tilesToDestroy[i] = layer.putTileAt(indexes.DESTROYED, tx, ty);
			}
			for (var i = 0; i < tilesToDestroy.length; ++i)
			{
				var t = tilesToDestroy[i];
				checkNeighbor(layer, t.x-1, t.y, nextDestruct);
				checkNeighbor(layer, t.x+1, t.y, nextDestruct);
				checkNeighbor(layer, t.x, t.y-1, nextDestruct);
				checkNeighbor(layer, t.x, t.y+1, nextDestruct);
			}
			tilesToDestroy = Object.values(nextDestruct);
			destruction_ticker = 0;
			console.log(tilesToDestroy);
		}

		var playerBody = player.body;

		playerBody.setVelocity(0);

		if (cursors.left.isDown)
		{
			playerBody.setVelocityX(-350);
			//this.cameras.main.followOffset.x = 300;
		}
		else if (cursors.right.isDown)
		{
			playerBody.setVelocityX(350);
			//this.cameras.main.followOffset.x = -300;
		}

		if (cursors.up.isDown)
		{
			playerBody.setVelocityY(-350);
		}
		else if (cursors.down.isDown)
		{
			playerBody.setVelocityY(350);
		}

		for ( var i = 0; i < swarmies.length; ++i )
		{
			var s = swarmies[i];
			s.spr.setPosition(player.x + s.off.x, player.y + s.off.y);
			s.spr.rotation += 0.01 * s.rot;
		}

		//gfxBodyDebug.clear();
		//playerBody.drawDebug(gfxBodyDebug);
	}

	// caveat: outer 'ring' of 2d lvl array must be zeroes to render correctly
	function tilemapFromLevel(scene, lvl)
	{

		var mapWidth = lvl[0].length * 2;
		var mapHeight = lvl[0].length * 2;

		var map = scene.make.tilemap({
			//key: 'map',
			tileWidth: 32,
			tileHeight: 32,
			width: mapWidth,
			height: mapHeight
		});

		var tileset = map.addTilesetImage('tileset_tiles', 'image_tiles', 32, 32);

		var testLayer = map.createBlankDynamicLayer('walls', tileset);

		var hasUp = function(lvl, c, r) {
			return (r > 0) ? lvl[r-1][c] == 1 : false;
		};
		var hasLeft = function(lvl, c, r) {
			return (c > 0) ? lvl[r][c-1] == 1 : false;
		};
		var hasDown = function(lvl, c, r) {
			return (r < lvl.length-2) ? lvl[r+1][c] == 1 : false;
		};
		var hasRight = function(lvl, c, r) {
			return (c < lvl[r].length-2) ? lvl[r][c+1] == 1 : false;
		};
		//for checking corners
		var isFloor = function(lvl, c, r) {
			return (c >= 0 && c < lvl[0].length && r >= 0 && r < lvl.length) ? lvl[r][c] == 1: false;
		};

		var tl_corner_options = [ indexes.BOTC, indexes.RIGHT, indexes.CORNERTL, indexes.BOTR ];
		var tr_corner_options = [ indexes.BOTC, indexes.LEFT, indexes.CORNERTR, indexes.BOTL ];
		var bl_corner_options = [ indexes.TOPC, indexes.RIGHT, indexes.CORNERBL, indexes.TOPR ];
		var br_corner_options = [ indexes.TOPC, indexes.LEFT, indexes.CORNERBR, indexes.TOPL ];

		var evalWallTile = function( options, surround ) {
			if (surround[0] && surround[1])
				return options[2];

			else if (surround[0])
				return options[0];

			else if (surround[1])
				return options[1];

			else if (surround[2])
				return options[3];
			
			else
				return null;
		};

		for (var y = 0; y < lvl.length; ++y)
		{
			for (var x = 0; x < lvl[0].length; ++x)
			{
				if ( lvl[y][x] == 1 )
				{
					testLayer.fill(indexes.FLOOR, x*2, y*2, 2, 2);
					if (tilesToDestroy === null)
					{
						var t = testLayer.getTileAt(x*2, y*2);
						tilesToDestroy = [{x: t.x, y: t.y}];
						//tilesToDestroy = [testLayer.getTileAt(x*2, y*2)];
					}
				}
				else if ( lvl[y][x] == 0 )
				{
					var mapx = x*2;
					var mapy = y*2;

					var u = hasUp(lvl, x, y);
					var d = hasDown(lvl, x, y);
					var l = hasLeft(lvl, x, y);
					var r = hasRight(lvl, x, y);

					var tile = evalWallTile( tl_corner_options, [u, l, isFloor(lvl, x-1, y-1)] );
					if (tile !== null)
						testLayer.putTileAt( tile, mapx, mapy );

					tile = evalWallTile( tr_corner_options, [u, r, isFloor(lvl, x+1, y-1)] );
					if (tile !== null)
						testLayer.putTileAt( tile, mapx+1, mapy );

					tile = evalWallTile( bl_corner_options, [d, l, isFloor(lvl, x-1, y+1)] );
					if (tile !== null)
						testLayer.putTileAt( tile, mapx, mapy+1 );

					tile = evalWallTile( br_corner_options, [d, r, isFloor(lvl, x+1, y+1)] );
					if (tile !== null)
						testLayer.putTileAt( tile, mapx+1, mapy+1 );
				}
			}
		}

		testLayer.setCollisionByExclusion([indexes.FLOOR], true, true);

		//var gfx = scene.add.graphics();
		//map.renderDebug(gfx, {}, testLayer);

		return {map: map, wallLayer: testLayer};
	}

	function OnCollideWithDestroyed(sprite, tile)
	{
		this.cameras.main.flash(500, 255, 0, 0);
		this.cameras.main.shake(500, 0.005);
	}

	function genLevel()
	{
		var root = {
			x: 0,
			y: 0,
			w: 200,
			h: 100
		};

		var lvl = Array(root.h);
		for ( var i = 0; i < lvl.length; ++i )
			lvl[i] = Array(root.w).fill(1);

		var splitNodes = function(list)
		{
			var newList = [];
			for ( var i = 0; i < list.length; ++i)
			{
				var horiz = Phaser.Math.between(0,1);
				if ( horiz )
				{
					newList.push({
						x: list[i].x,
						y: list[i].y,
						w: list[i].w,
						h: list[i].h / 2
					});
					newList.push({
						x: list[i].x,
						y: list[i].y + list[i].h / 2,
						w: list[i].w,
						h: list[i].h / 2
					});
				}
				else
				{
					newList.push({
						x: list[i].x,
						y: list[i].y,
						w: list[i].w / 2,
						h: list[i].h
					});
					newList.push({
						x: list[i].x + list[i].w / 2,
						y: list[i].y,
						w: list[i].w / 2,
						h: list[i].h
					});
				}
			}
		};

		var nodeList = [root];

	}

    </script>

</body>
</html>
