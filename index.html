<!DOCTYPE html>
<html>
<head>
    <script src="phaser.min.js"></script>
</head>
<body>

	<h2>Running out of space</h2>
    <script>
    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 }
            }
        },
        scene: {
            preload: preload,
            create: create,
			update: update
        }
    };

    var game = new Phaser.Game(config);

    function preload ()
    {
		this.load.image('image_tiles', 'tiles_x2.png');
		this.load.image('swarm', 'swarm.png');
    }

	var cursors = null;
	var player = null;

    function create ()
    {
		var lvl = [
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0],
			[0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0],
			[0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
		];

		var map = tilemapFromLevel(this, lvl);

		player = this.physics.add.image(140, 100, 'swarm');
		this.physics.add.collider(player.body, map.getLayer('walls'));

		this.cameras.main.startFollow(player);

		cursors = this.input.keyboard.createCursorKeys();
    }

	function update()
	{
		var playerBody = player.body;

		playerBody.setVelocity(0);

		if (cursors.left.isDown)
		{
			playerBody.setVelocityX(-500);
			//this.cameras.main.followOffset.x = 300;
		}
		else if (cursors.right.isDown)
		{
			playerBody.setVelocityX(500);
			//this.cameras.main.followOffset.x = -300;
		}

		if (cursors.up.isDown)
		{
			playerBody.setVelocityY(-500);
		}
		else if (cursors.down.isDown)
		{
			playerBody.setVelocityY(500);
		}
	}

	// caveat: outer 'ring' of 2d lvl array must be zeroes to render correctly
	function tilemapFromLevel(scene, lvl)
	{
		var indexes = {
			TOPL: 0,
			TOPC: 1,
			TOPR: 2,
			LEFT: 8,
			FLOOR: 14,
			RIGHT: 10,
			BOTL:  16,
			BOTC: 17,
			BOTR: 18,

			CORNERTL: 3,
			CORNERTR: 4,
			CORNERBL: 11,
			CORNERBR: 12
		};

		var mapWidth = lvl[0].length * 2;
		var mapHeight = lvl[0].length * 2;

		var map = scene.make.tilemap({
			//key: 'map',
			tileWidth: 32,
			tileHeight: 32,
			width: mapWidth,
			height: mapHeight
		});

		var tileset = map.addTilesetImage('tileset_tiles', 'image_tiles', 32, 32);

		var testLayer = map.createBlankDynamicLayer('walls', tileset);

		var hasUp = function(lvl, c, r) {
			return (r > 0) ? lvl[r-1][c] == 1 : false;
		};
		var hasLeft = function(lvl, c, r) {
			return (c > 0) ? lvl[r][c-1] == 1 : false;
		};
		var hasDown = function(lvl, c, r) {
			return (r < lvl.length-2) ? lvl[r+1][c] == 1 : false;
		};
		var hasRight = function(lvl, c, r) {
			return (c < lvl[r].length-2) ? lvl[r][c+1] == 1 : false;
		};
		//for checking corners
		var isFloor = function(lvl, c, r) {
			return (c >= 0 && c < lvl[0].length && r >= 0 && r < lvl.length) ? lvl[r][c] == 1: false;
		};

		var tl_corner_options = [ indexes.BOTC, indexes.RIGHT, indexes.CORNERTL, indexes.BOTR ];
		var tr_corner_options = [ indexes.BOTC, indexes.LEFT, indexes.CORNERTR, indexes.BOTL ];
		var bl_corner_options = [ indexes.TOPC, indexes.RIGHT, indexes.CORNERBL, indexes.TOPR ];
		var br_corner_options = [ indexes.TOPC, indexes.LEFT, indexes.CORNERBR, indexes.TOPL ];

		var evalWallTile = function( options, surround ) {
			if (surround[0] && surround[1])
				return options[2];

			else if (surround[0])
				return options[0];

			else if (surround[1])
				return options[1];

			else if (surround[2])
				return options[3];
			
			else
				return null;
		};

		for (var y = 0; y < lvl.length; ++y)
		{
			for (var x = 0; x < lvl[0].length; ++x)
			{
				if ( lvl[y][x] == 1 )
				{
					testLayer.fill(indexes.FLOOR, x*2, y*2, 2, 2);
				}
				else if ( lvl[y][x] == 0 )
				{
					var mapx = x*2;
					var mapy = y*2;

					var u = hasUp(lvl, x, y);
					var d = hasDown(lvl, x, y);
					var l = hasLeft(lvl, x, y);
					var r = hasRight(lvl, x, y);

					var tile = evalWallTile( tl_corner_options, [u, l, isFloor(lvl, x-1, y-1)] );
					if (tile !== null)
						testLayer.putTileAt( tile, mapx, mapy );

					tile = evalWallTile( tr_corner_options, [u, r, isFloor(lvl, x+1, y-1)] );
					if (tile !== null)
						testLayer.putTileAt( tile, mapx+1, mapy );

					tile = evalWallTile( bl_corner_options, [d, l, isFloor(lvl, x-1, y+1)] );
					if (tile !== null)
						testLayer.putTileAt( tile, mapx, mapy+1 );

					tile = evalWallTile( br_corner_options, [d, r, isFloor(lvl, x+1, y+1)] );
					if (tile !== null)
						testLayer.putTileAt( tile, mapx+1, mapy+1 );
				}
			}
		}

		testLayer.setCollisionByExclusion([indexes.FLOOR], true, true);

		return map;
	}
    </script>

</body>
</html>
